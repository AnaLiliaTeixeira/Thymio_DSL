/*
 * generated by Xtext 2.34.0.M2
 */
package org.xtext.project.tdsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.project.tdsl.services.TDslGrammarAccess;
import thymio_DSL.ArithmeticExpression;
import thymio_DSL.Button;
import thymio_DSL.ClapEvent;
import thymio_DSL.ColorBottomAction;
import thymio_DSL.ColorTopAction;
import thymio_DSL.Condition;
import thymio_DSL.IfStatement;
import thymio_DSL.MovementAction;
import thymio_DSL.ProxEvent;
import thymio_DSL.Sensor;
import thymio_DSL.SoundAction;
import thymio_DSL.Statement;
import thymio_DSL.TapEvent;
import thymio_DSL.ThymioDSL;
import thymio_DSL.Thymio_DSLPackage;
import thymio_DSL.UpperEvent;

@SuppressWarnings("all")
public class TDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private TDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == Thymio_DSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Thymio_DSLPackage.ARITHMETIC_EXPRESSION:
				sequence_ArithmeticExpression(context, (ArithmeticExpression) semanticObject); 
				return; 
			case Thymio_DSLPackage.BUTTON:
				sequence_Button(context, (Button) semanticObject); 
				return; 
			case Thymio_DSLPackage.CLAP_EVENT:
				sequence_ClapEvent(context, (ClapEvent) semanticObject); 
				return; 
			case Thymio_DSLPackage.COLOR_BOTTOM_ACTION:
				sequence_ColorBottomAction(context, (ColorBottomAction) semanticObject); 
				return; 
			case Thymio_DSLPackage.COLOR_TOP_ACTION:
				sequence_ColorTopAction(context, (ColorTopAction) semanticObject); 
				return; 
			case Thymio_DSLPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case Thymio_DSLPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case Thymio_DSLPackage.MOVEMENT_ACTION:
				sequence_MovementAction(context, (MovementAction) semanticObject); 
				return; 
			case Thymio_DSLPackage.PROX_EVENT:
				sequence_ProxEvent(context, (ProxEvent) semanticObject); 
				return; 
			case Thymio_DSLPackage.SENSOR:
				sequence_Sensor(context, (Sensor) semanticObject); 
				return; 
			case Thymio_DSLPackage.SOUND_ACTION:
				sequence_SoundAction(context, (SoundAction) semanticObject); 
				return; 
			case Thymio_DSLPackage.STATEMENT:
				sequence_Statement(context, (Statement) semanticObject); 
				return; 
			case Thymio_DSLPackage.TAP_EVENT:
				sequence_TapEvent(context, (TapEvent) semanticObject); 
				return; 
			case Thymio_DSLPackage.THYMIO_DSL:
				sequence_ThymioDSL(context, (ThymioDSL) semanticObject); 
				return; 
			case Thymio_DSLPackage.UPPER_EVENT:
				sequence_UpperEvent(context, (UpperEvent) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     ArithmeticExpression returns ArithmeticExpression
	 *
	 * Constraint:
	 *     (left=EIntegerObject ((operator='+' | operator='-' | operator='*' | operator='/' | operator='mod') right=EIntegerObject)?)
	 * </pre>
	 */
	protected void sequence_ArithmeticExpression(ISerializationContext context, ArithmeticExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Button returns Button
	 *
	 * Constraint:
	 *     name=Buttons
	 * </pre>
	 */
	protected void sequence_Button(ISerializationContext context, Button semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Thymio_DSLPackage.Literals.BUTTON__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Thymio_DSLPackage.Literals.BUTTON__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getButtonAccess().getNameButtonsParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Event returns ClapEvent
	 *     ClapEvent returns ClapEvent
	 *
	 * Constraint:
	 *     {ClapEvent}
	 * </pre>
	 */
	protected void sequence_ClapEvent(ISerializationContext context, ClapEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns ColorBottomAction
	 *     ColorBottomAction returns ColorBottomAction
	 *
	 * Constraint:
	 *     color=Color?
	 * </pre>
	 */
	protected void sequence_ColorBottomAction(ISerializationContext context, ColorBottomAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns ColorTopAction
	 *     ColorTopAction returns ColorTopAction
	 *
	 * Constraint:
	 *     color=Color?
	 * </pre>
	 */
	protected void sequence_ColorTopAction(ISerializationContext context, ColorTopAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (leftSensor=Sensor ((operator='and' | operator='or') rightSensor=Sensor)?)
	 * </pre>
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (condition=Condition action+=Action+)
	 * </pre>
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns MovementAction
	 *     MovementAction returns MovementAction
	 *
	 * Constraint:
	 *     (((direction='forward' | direction='backward') speed=ArithmeticExpression?) | direction=RightLeft | direction='driving' | direction='turning')
	 * </pre>
	 */
	protected void sequence_MovementAction(ISerializationContext context, MovementAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Event returns ProxEvent
	 *     ProxEvent returns ProxEvent
	 *
	 * Constraint:
	 *     sensor=Sensor
	 * </pre>
	 */
	protected void sequence_ProxEvent(ISerializationContext context, ProxEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Thymio_DSLPackage.Literals.PROX_EVENT__SENSOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Thymio_DSLPackage.Literals.PROX_EVENT__SENSOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProxEventAccess().getSensorSensorParserRuleCall_1_0(), semanticObject.getSensor());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Sensor returns Sensor
	 *
	 * Constraint:
	 *     (
	 *         (direction=HorizontalSensors sensor_type='horizontal' state=State_Horizontal_Sensor) | 
	 *         (direction=RightLeft sensor_type='ground' state=State_Ground_Sensor)
	 *     )
	 * </pre>
	 */
	protected void sequence_Sensor(ISerializationContext context, Sensor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns SoundAction
	 *     SoundAction returns SoundAction
	 *
	 * Constraint:
	 *     sound=Sound?
	 * </pre>
	 */
	protected void sequence_SoundAction(ISerializationContext context, SoundAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Statement
	 *
	 * Constraint:
	 *     (event=Event (ifstatement+=IfStatement | action+=Action)+)
	 * </pre>
	 */
	protected void sequence_Statement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Event returns TapEvent
	 *     TapEvent returns TapEvent
	 *
	 * Constraint:
	 *     {TapEvent}
	 * </pre>
	 */
	protected void sequence_TapEvent(ISerializationContext context, TapEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ThymioDSL returns ThymioDSL
	 *
	 * Constraint:
	 *     statement+=Statement+
	 * </pre>
	 */
	protected void sequence_ThymioDSL(ISerializationContext context, ThymioDSL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Event returns UpperEvent
	 *     UpperEvent returns UpperEvent
	 *
	 * Constraint:
	 *     (button+=Button button+=Button* state=State)
	 * </pre>
	 */
	protected void sequence_UpperEvent(ISerializationContext context, UpperEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
